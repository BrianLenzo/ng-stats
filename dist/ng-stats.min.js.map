{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/ng-stats.min.js","webpack:///webpack/bootstrap c40d2e1fa1e20c078c1c","webpack:///./index.js","webpack:///external \"angular\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","hijackDigest","digestIsHijacked","scopePrototype","Object","getPrototypeOf","getRootScope","oldDigest","$digest","start","timerNow","apply","arguments","diff","updateData","getWatcherCount","isChromeApp","chrome","storage","local","autoload","options","window","self","angular","showAngularStats","setTimeout","opts","track","thingToTrack","listenerCollection","diffOnly","capThingToTrack","charAt","toUpperCase","slice","returnData","tracked","length","push","log","thingToLog","capThingToLog","last","color","colorLog","console","getColor","metric","threshold","digestTimeThreshold","watchCountThreshold","addDataToCanvas","watchCount","digestLength","averageDigest","lastDigestLength","digestColor","lastWatchCount","nullOrUndef","watchColor","$watchCount","text","css","$digestTime","toFixed","ctx","cvs","getContext","noDigestSteps","fillStyle","fillRect","graphSz","width","height","Math","max","shiftLeft","state","active","imageData","getImageData","putImageData","undefined","listeners","current","$el","remove","sessionStorage","removeItem","autoloadKey","localStorage","position","extend","htmlId","trackDigest","trackWatches","logDigest","logWatches","styles","background","borderBottom","borderRight","fontFamily","zIndex","textAlign","top","indexOf","bottom","right","left","setItem","JSON","stringify","Error","bodyEl","element","document","body","append","find","next","attr","ngStatsAddToCanvas","$rootScope","$$phase","scopeEl","querySelector","scopeSelectors","scope","$root","clearTimeout","watchCountTimeout","now","lastWatchCountRun","getWatcherCountForScope","getWatcherCountForElement","startingScope","getClosestChildScope","getWatchersFromScope","$$watchers","forEach","listener","item","count","iterateScopes","childScope","currentScope","fn","_makeScopeReference","ret","iterateChildren","iterateSiblings","$$nextSibling","$$childHead","getScopeById","myScope","$id","_isScopeId","defineProperty","value","_angular","_angular2","version","performance","Date","autoloadOptions","parse","directive","findRootOfElement","el","parent","parentElement","index","watchCountRoot","onDigestLengthUpdate","onWatchCountUpdate","link","attrs","setupDigestLengthElement","hasOwnProperty","digestEl","directiveIndex","dirDigestNode","setupWatchCountElement","watchCountEl","rootParent","addWatchCountListener","addDigestLengthListener","destroyListeners","$on"],"mappings":"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","file":"dist/ng-stats.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"showAngularStats\"] = factory(require(\"angular\"));\n\telse\n\t\troot[\"showAngularStats\"] = factory(root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","//! ng-stats version 2.4.0 built with ♥ by Kent C. Dodds <kent@doddsfamily.us> (http://kent.doddsfamily.us), Viper Bailey <jinxidoru@gmail.com> (http://jinxidoru.blogspot.com), Daniel Lamb <dlamb.open.source@gmail.com> (http://daniellmb.com) (ó ì_í)=óò=(ì_í ò)\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"showAngularStats\"] = factory(require(\"angular\"));\n\telse\n\t\troot[\"showAngularStats\"] = factory(root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* eslint no-console:0 */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar angular = _angular2['default'];\n\t\n\t/* istanbul ignore next */\n\tif (!angular.version) {\n\t  // we're doing this because some versions\n\t  // of angular don't expose itself correctly\n\t  angular = window.angular;\n\t}\n\t\n\texports['default'] = showAngularStats;\n\t\n\tvar autoloadKey = 'showAngularStats_autoload';\n\tvar current = null;\n\t// define the timer function to use based upon whether or not 'performance is available'\n\tvar timerNow = window.self.performance && window.self.performance.now ? function () {\n\t  return window.self.performance.now();\n\t} : function () {\n\t  return Date.now();\n\t};\n\t\n\tvar lastWatchCountRun = timerNow();\n\tvar watchCountTimeout = null;\n\tvar lastWatchCount = getWatcherCount() || 0;\n\tvar lastDigestLength = 0;\n\tvar scopeSelectors = '.ng-scope, .ng-isolate-scope';\n\tvar $rootScope;\n\t\n\tvar digestIsHijacked = false;\n\t\n\tvar listeners = {\n\t  watchCount: {},\n\t  digestLength: {}\n\t};\n\t\n\t// Hijack $digest to time it and update data on every digest.\n\tfunction hijackDigest() {\n\t  if (digestIsHijacked) {\n\t    return;\n\t  }\n\t  digestIsHijacked = true;\n\t  var scopePrototype = Object.getPrototypeOf(getRootScope());\n\t  var oldDigest = scopePrototype.$digest;\n\t  scopePrototype.$digest = function $digest() {\n\t    var start = timerNow();\n\t    oldDigest.apply(this, arguments);\n\t    var diff = timerNow() - start;\n\t    updateData(getWatcherCount(), diff);\n\t  };\n\t}\n\t\n\t// used to prevent localstorage error in chrome packaged apps\n\tfunction isChromeApp() {\n\t  return typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined' && typeof chrome.storage.local !== 'undefined';\n\t}\n\t\n\t// check for autoload\n\tvar autoloadOptions = sessionStorage[autoloadKey] || !isChromeApp() && localStorage[autoloadKey];\n\tif (autoloadOptions) {\n\t  autoload(JSON.parse(autoloadOptions));\n\t}\n\t\n\tfunction autoload(options) {\n\t  if (window.self.angular && getRootScope()) {\n\t    showAngularStats(options);\n\t  } else {\n\t    // wait for angular to load...\n\t    window.self.setTimeout(function () {\n\t      autoload(options);\n\t    }, 200);\n\t  }\n\t}\n\t\n\tfunction showAngularStats(opts) {\n\t  /* eslint max-statements:[2, 45] */\n\t  /* eslint complexity:[2, 18] */\n\t  /* eslint consistent-return:0 */\n\t  // TODO ^^ fix these things...\n\t  opts = opts !== undefined ? opts : {};\n\t  var returnData = {\n\t    listeners: listeners\n\t  };\n\t  // delete the previous one\n\t  if (current) {\n\t    current.$el && current.$el.remove();\n\t    current.active = false;\n\t    current = null;\n\t  }\n\t\n\t  // Remove autoload if they did not specifically request it\n\t  if (opts === false || !opts.autoload) {\n\t    sessionStorage.removeItem(autoloadKey);\n\t    localStorage.removeItem(autoloadKey);\n\t    // do nothing if the argument is false\n\t    if (opts === false) {\n\t      return;\n\t    }\n\t  }\n\t\n\t  opts.position = opts.position || 'top-left';\n\t  opts = angular.extend({\n\t    htmlId: null,\n\t    digestTimeThreshold: 16,\n\t    watchCountThreshold: 2000,\n\t    autoload: false,\n\t    trackDigest: false,\n\t    trackWatches: false,\n\t    logDigest: false,\n\t    logWatches: false,\n\t    styles: {\n\t      position: 'fixed',\n\t      background: 'black',\n\t      borderBottom: '1px solid #666',\n\t      borderRight: '1px solid #666',\n\t      color: '#666',\n\t      fontFamily: 'Courier',\n\t      width: 130,\n\t      zIndex: 9999,\n\t      textAlign: 'right',\n\t      top: opts.position.indexOf('top') === -1 ? null : 0,\n\t      bottom: opts.position.indexOf('bottom') === -1 ? null : 0,\n\t      right: opts.position.indexOf('right') === -1 ? null : 0,\n\t      left: opts.position.indexOf('left') === -1 ? null : 0\n\t    }\n\t  }, opts || {});\n\t\n\t  hijackDigest();\n\t\n\t  // setup the state\n\t  var state = current = { active: true };\n\t\n\t  // auto-load on startup\n\t  if (opts.autoload) {\n\t    if (opts.autoload === 'localStorage') {\n\t      localStorage.setItem(autoloadKey, JSON.stringify(opts));\n\t    } else if (opts.autoload === 'sessionStorage' || typeof opts.autoload === 'boolean') {\n\t      sessionStorage.setItem(autoloadKey, JSON.stringify(opts));\n\t    } else {\n\t      throw new Error('Invalid value for autoload: ' + opts.autoload + ' can only be \"localStorage\" \"sessionStorage\" or boolean.');\n\t    }\n\t  }\n\t\n\t  // general variables\n\t  var bodyEl = angular.element(document.body);\n\t  var noDigestSteps = 0;\n\t\n\t  // add the DOM element\n\t  var htmlId = opts.htmlId ? ' id=\"' + opts.htmlId + '\"' : '';\n\t  state.$el = angular.element('<div' + htmlId + '><canvas></canvas><div><span></span> | <span></span></div></div>').css(opts.styles);\n\t  bodyEl.append(state.$el);\n\t  var $watchCount = state.$el.find('span');\n\t  var $digestTime = $watchCount.next();\n\t\n\t  // initialize the canvas\n\t  var graphSz = { width: 130, height: 40 };\n\t  var cvs = state.$el.find('canvas').attr(graphSz)[0];\n\t\n\t  // add listeners\n\t  listeners.digestLength.ngStatsAddToCanvas = function (digestLength) {\n\t    addDataToCanvas(null, digestLength);\n\t  };\n\t\n\t  listeners.watchCount.ngStatsAddToCanvas = function (watchCount) {\n\t    addDataToCanvas(watchCount);\n\t  };\n\t\n\t  track('digest', listeners.digestLength);\n\t  track('watches', listeners.watchCount, true);\n\t\n\t  log('digest', listeners.digestLength);\n\t  log('watches', listeners.watchCount, true);\n\t\n\t  function track(thingToTrack, listenerCollection, diffOnly) {\n\t    var capThingToTrack = thingToTrack.charAt(0).toUpperCase() + thingToTrack.slice(1);\n\t    if (opts['track' + capThingToTrack]) {\n\t      returnData[thingToTrack] = [];\n\t      listenerCollection['track + capThingToTrack'] = function (tracked) {\n\t        if (!diffOnly || returnData[thingToTrack][returnData.length - 1] !== tracked) {\n\t          returnData[thingToTrack][returnData.length - 1] = tracked;\n\t          returnData[thingToTrack].push(tracked);\n\t        }\n\t      };\n\t    }\n\t  }\n\t\n\t  function log(thingToLog, listenerCollection, diffOnly) {\n\t    var capThingToLog = thingToLog.charAt(0).toUpperCase() + thingToLog.slice(1);\n\t    if (opts['log' + capThingToLog]) {\n\t      var last;\n\t      listenerCollection['log' + capThingToLog] = function (tracked) {\n\t        if (!diffOnly || last !== tracked) {\n\t          last = tracked;\n\t          var color = colorLog(thingToLog, tracked);\n\t          if (color) {\n\t            console.log('%c' + thingToLog + ':', color, tracked);\n\t          } else {\n\t            console.log(thingToLog + ':', tracked);\n\t          }\n\t        }\n\t      };\n\t    }\n\t  }\n\t\n\t  function getColor(metric, threshold) {\n\t    if (metric > threshold) {\n\t      return 'red';\n\t    } else if (metric > 0.7 * threshold) {\n\t      return 'orange';\n\t    }\n\t    return 'green';\n\t  }\n\t\n\t  function colorLog(thingToLog, tracked) {\n\t    var color;\n\t    if (thingToLog === 'digest') {\n\t      color = 'color:' + getColor(tracked, opts.digestTimeThreshold);\n\t    } else if (thingToLog === 'watches') {\n\t      color = 'color:' + getColor(tracked, opts.watchCountThreshold);\n\t    }\n\t    return color;\n\t  }\n\t\n\t  function addDataToCanvas(watchCount, digestLength) {\n\t    var averageDigest = digestLength || lastDigestLength;\n\t    var digestColor = getColor(averageDigest, opts.digestTimeThreshold);\n\t    lastWatchCount = nullOrUndef(watchCount) ? lastWatchCount : watchCount;\n\t    var watchColor = getColor(lastWatchCount, opts.watchCountThreshold);\n\t    lastDigestLength = nullOrUndef(digestLength) ? lastDigestLength : digestLength;\n\t    $watchCount.text(lastWatchCount).css({ color: watchColor });\n\t    $digestTime.text(lastDigestLength.toFixed(2)).css({ color: digestColor });\n\t\n\t    if (!digestLength) {\n\t      return;\n\t    }\n\t\n\t    // color the sliver if this is the first step\n\t    var ctx = cvs.getContext('2d');\n\t    if (noDigestSteps > 0) {\n\t      noDigestSteps = 0;\n\t      ctx.fillStyle = '#333';\n\t      ctx.fillRect(graphSz.width - 1, 0, 1, graphSz.height);\n\t    }\n\t\n\t    // mark the point on the graph\n\t    ctx.fillStyle = digestColor;\n\t    ctx.fillRect(graphSz.width - 1, Math.max(0, graphSz.height - averageDigest), 2, 2);\n\t  }\n\t\n\t  // Shift the canvas to the left.\n\t  function shiftLeft() {\n\t    if (state.active) {\n\t      window.self.setTimeout(shiftLeft, 250);\n\t      var ctx = cvs.getContext('2d');\n\t      var imageData = ctx.getImageData(1, 0, graphSz.width - 1, graphSz.height);\n\t      ctx.putImageData(imageData, 0, 0);\n\t      ctx.fillStyle = noDigestSteps++ > 2 ? 'black' : '#333';\n\t      ctx.fillRect(graphSz.width - 1, 0, 1, graphSz.height);\n\t    }\n\t  }\n\t\n\t  // start everything\n\t  shiftLeft();\n\t  if (!$rootScope.$$phase) {\n\t    $rootScope.$digest();\n\t  }\n\t\n\t  return returnData;\n\t}\n\t\n\tangular.module('angularStats', []).directive('angularStats', function () {\n\t  var index = 1;\n\t  return {\n\t    scope: {\n\t      digestLength: '@',\n\t      watchCount: '@',\n\t      watchCountRoot: '@',\n\t      onDigestLengthUpdate: '&?',\n\t      onWatchCountUpdate: '&?'\n\t    },\n\t    link: function link(scope, el, attrs) {\n\t      hijackDigest();\n\t      var directiveIndex = index++;\n\t\n\t      setupDigestLengthElement();\n\t      setupWatchCountElement();\n\t      addWatchCountListener();\n\t      addDigestLengthListener();\n\t      scope.$on('$destroy', destroyListeners);\n\t\n\t      function setupDigestLengthElement() {\n\t        if (attrs.hasOwnProperty('digestLength')) {\n\t          var digestEl = el;\n\t          if (attrs.digestLength) {\n\t            digestEl = angular.element(el[0].querySelector(attrs.digestLength));\n\t          }\n\t          listeners.digestLength['ngStatsDirective' + directiveIndex] = function (length) {\n\t            window.dirDigestNode = digestEl[0];\n\t            digestEl.text((length || 0).toFixed(2));\n\t          };\n\t        }\n\t      }\n\t\n\t      function setupWatchCountElement() {\n\t        if (attrs.hasOwnProperty('watchCount')) {\n\t          var watchCountRoot;\n\t          var watchCountEl = el;\n\t          if (scope.watchCount) {\n\t            watchCountEl = angular.element(el[0].querySelector(attrs.watchCount));\n\t          }\n\t\n\t          if (scope.watchCountRoot) {\n\t            if (scope.watchCountRoot === 'this') {\n\t              watchCountRoot = el;\n\t            } else {\n\t              // In the case this directive is being compiled and it's not in the dom,\n\t              // we're going to do the find from the root of what we have...\n\t              var rootParent;\n\t              if (attrs.hasOwnProperty('watchCountOfChild')) {\n\t                rootParent = el[0];\n\t              } else {\n\t                rootParent = findRootOfElement(el);\n\t              }\n\t              watchCountRoot = angular.element(rootParent.querySelector(scope.watchCountRoot));\n\t              if (!watchCountRoot.length) {\n\t                throw new Error('no element at selector: ' + scope.watchCountRoot);\n\t              }\n\t            }\n\t          }\n\t\n\t          listeners.watchCount['ngStatsDirective' + directiveIndex] = function (count) {\n\t            var watchCount = count;\n\t            if (watchCountRoot) {\n\t              watchCount = getWatcherCountForElement(watchCountRoot);\n\t            }\n\t            watchCountEl.text(watchCount);\n\t          };\n\t        }\n\t      }\n\t\n\t      function addWatchCountListener() {\n\t        if (attrs.hasOwnProperty('onWatchCountUpdate')) {\n\t          listeners.watchCount['ngStatsDirectiveUpdate' + directiveIndex] = function (count) {\n\t            scope.onWatchCountUpdate({ watchCount: count });\n\t          };\n\t        }\n\t      }\n\t\n\t      function addDigestLengthListener() {\n\t        if (attrs.hasOwnProperty('onDigestLengthUpdate')) {\n\t          listeners.digestLength['ngStatsDirectiveUpdate' + directiveIndex] = function (length) {\n\t            scope.onDigestLengthUpdate({ digestLength: length });\n\t          };\n\t        }\n\t      }\n\t\n\t      function destroyListeners() {\n\t        delete listeners.digestLength['ngStatsDirectiveUpdate' + directiveIndex];\n\t        delete listeners.watchCount['ngStatsDirectiveUpdate' + directiveIndex];\n\t        delete listeners.digestLength['ngStatsDirective' + directiveIndex];\n\t        delete listeners.watchCount['ngStatsDirective' + directiveIndex];\n\t      }\n\t    }\n\t  };\n\t\n\t  function findRootOfElement(el) {\n\t    var parent = el[0];\n\t    while (parent.parentElement) {\n\t      parent = parent.parentElement;\n\t    }\n\t    return parent;\n\t  }\n\t});\n\t\n\t// UTILITY FUNCTIONS\n\t\n\tfunction getRootScope() {\n\t  if ($rootScope) {\n\t    return $rootScope;\n\t  }\n\t  var scopeEl = document.querySelector(scopeSelectors);\n\t  if (!scopeEl) {\n\t    return null;\n\t  }\n\t  $rootScope = angular.element(scopeEl).scope().$root;\n\t  return $rootScope;\n\t}\n\t\n\t// Uses timeouts to ensure that this is only run every 300ms (it's a perf bottleneck)\n\tfunction getWatcherCount() {\n\t  window.self.clearTimeout(watchCountTimeout);\n\t  var now = timerNow();\n\t  if (now - lastWatchCountRun > 300) {\n\t    lastWatchCountRun = now;\n\t    lastWatchCount = getWatcherCountForScope();\n\t  } else {\n\t    watchCountTimeout = window.self.setTimeout(function () {\n\t      updateData(getWatcherCount());\n\t    }, 350);\n\t  }\n\t  return lastWatchCount;\n\t}\n\t\n\tfunction getWatcherCountForElement(element) {\n\t  var startingScope = getClosestChildScope(element);\n\t  return getWatcherCountForScope(startingScope);\n\t}\n\t\n\tfunction getClosestChildScope(element) {\n\t  element = angular.element(element);\n\t  var scope = element.scope();\n\t  if (!scope) {\n\t    element = angular.element(element.querySelector(scopeSelectors));\n\t    scope = element.scope();\n\t  }\n\t  return scope;\n\t}\n\t\n\tfunction getWatchersFromScope(scope) {\n\t  return scope && scope.$$watchers ? scope.$$watchers : [];\n\t}\n\t\n\t// iterate through listeners to call them with the watchCount and digestLength\n\tfunction updateData(watchCount, digestLength) {\n\t  // update the listeners\n\t  if (!nullOrUndef(watchCount)) {\n\t    angular.forEach(listeners.watchCount, function (listener) {\n\t      listener(watchCount);\n\t    });\n\t  }\n\t  if (!nullOrUndef(digestLength)) {\n\t    angular.forEach(listeners.digestLength, function (listener) {\n\t      listener(digestLength);\n\t    });\n\t  }\n\t}\n\t\n\tfunction nullOrUndef(item) {\n\t  return item === null || item === undefined;\n\t}\n\t\n\tfunction getWatcherCountForScope(scope) {\n\t  var count = 0;\n\t  iterateScopes(scope, function (childScope) {\n\t    count += getWatchersFromScope(childScope).length;\n\t  });\n\t  return count;\n\t}\n\t\n\tfunction iterateScopes(currentScope, fn) {\n\t  if (typeof currentScope === 'function') {\n\t    fn = currentScope;\n\t    currentScope = null;\n\t  }\n\t  currentScope = currentScope || getRootScope();\n\t  currentScope = _makeScopeReference(currentScope);\n\t  if (!currentScope) {\n\t    return;\n\t  }\n\t  var ret = fn(currentScope);\n\t  if (ret === false) {\n\t    return ret;\n\t  }\n\t  return iterateChildren(currentScope, fn);\n\t}\n\t\n\tfunction iterateSiblings(start, fn) {\n\t  var ret;\n\t  /* eslint no-extra-boolean-cast:0 */\n\t  while (!!(start = start.$$nextSibling)) {\n\t    ret = fn(start);\n\t    if (ret === false) {\n\t      break;\n\t    }\n\t\n\t    ret = iterateChildren(start, fn);\n\t    if (ret === false) {\n\t      break;\n\t    }\n\t  }\n\t  return ret;\n\t}\n\t\n\tfunction iterateChildren(start, fn) {\n\t  var ret;\n\t  while (!!(start = start.$$childHead)) {\n\t    ret = fn(start);\n\t    if (ret === false) {\n\t      break;\n\t    }\n\t\n\t    ret = iterateSiblings(start, fn);\n\t    if (ret === false) {\n\t      break;\n\t    }\n\t  }\n\t  return ret;\n\t}\n\t\n\tfunction getScopeById(id) {\n\t  var myScope = null;\n\t  iterateScopes(function (scope) {\n\t    if (scope.$id === id) {\n\t      myScope = scope;\n\t      return false;\n\t    }\n\t  });\n\t  return myScope;\n\t}\n\t\n\tfunction _makeScopeReference(scope) {\n\t  if (_isScopeId(scope)) {\n\t    scope = getScopeById(scope);\n\t  }\n\t  return scope;\n\t}\n\t\n\tfunction _isScopeId(scope) {\n\t  return typeof scope === 'string' || typeof scope === 'number';\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dist/ng-stats.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c40d2e1fa1e20c078c1c\n **/","/* eslint no-console:0 */\nimport ng from 'angular';\n\nlet angular = ng;\n\n/* istanbul ignore next */\nif (!angular.version) {\n  // we're doing this because some versions\n  // of angular don't expose itself correctly\n  angular = window.angular;\n}\n\nexport default showAngularStats;\n\nvar autoloadKey = 'showAngularStats_autoload';\nvar current = null;\n// define the timer function to use based upon whether or not 'performance is available'\nvar timerNow = window.self.performance && window.self.performance.now\n  ? () => window.self.performance.now()\n  : () => Date.now();\n\nvar lastWatchCountRun = timerNow();\nvar watchCountTimeout = null;\nvar lastWatchCount = getWatcherCount() || 0;\nvar lastDigestLength = 0;\nvar scopeSelectors = '.ng-scope, .ng-isolate-scope';\nvar $rootScope;\n\nvar digestIsHijacked = false;\n\nvar listeners = {\n  watchCount: {},\n  digestLength: {}\n};\n\n// Hijack $digest to time it and update data on every digest.\nfunction hijackDigest() {\n  if (digestIsHijacked) {\n    return;\n  }\n  digestIsHijacked = true;\n  var scopePrototype = Object.getPrototypeOf(getRootScope());\n  var oldDigest = scopePrototype.$digest;\n  scopePrototype.$digest = function $digest() {\n    var start = timerNow();\n    oldDigest.apply(this, arguments);\n    var diff = (timerNow() - start);\n    updateData(getWatcherCount(), diff);\n  };\n}\n\n// used to prevent localstorage error in chrome packaged apps\nfunction isChromeApp() {\n  return (typeof chrome !== 'undefined' &&\n  typeof chrome.storage !== 'undefined' &&\n  typeof chrome.storage.local !== 'undefined');\n}\n\n// check for autoload\nvar autoloadOptions = sessionStorage[autoloadKey] || (!isChromeApp() && localStorage[autoloadKey]);\nif (autoloadOptions) {\n  autoload(JSON.parse(autoloadOptions));\n}\n\nfunction autoload(options) {\n  if (window.self.angular && getRootScope()) {\n    showAngularStats(options);\n  } else {\n    // wait for angular to load...\n    window.self.setTimeout(function() {\n      autoload(options);\n    }, 200);\n  }\n}\n\nfunction showAngularStats(opts) {\n  /* eslint max-statements:[2, 45] */\n  /* eslint complexity:[2, 18] */\n  /* eslint consistent-return:0 */\n  // TODO ^^ fix these things...\n  opts = opts !== undefined ? opts : {};\n  var returnData = {\n    listeners: listeners\n  };\n  // delete the previous one\n  if (current) {\n    current.$el && current.$el.remove();\n    current.active = false;\n    current = null;\n  }\n\n  // Remove autoload if they did not specifically request it\n  if (opts === false || !opts.autoload) {\n    sessionStorage.removeItem(autoloadKey);\n    localStorage.removeItem(autoloadKey);\n    // do nothing if the argument is false\n    if (opts === false) {\n      return;\n    }\n  }\n\n  opts.position = opts.position || 'top-left';\n  opts = angular.extend({\n    htmlId: null,\n    digestTimeThreshold: 16,\n    watchCountThreshold: 2000,\n    autoload: false,\n    trackDigest: false,\n    trackWatches: false,\n    logDigest: false,\n    logWatches: false,\n    styles: {\n      position: 'fixed',\n      background: 'black',\n      borderBottom: '1px solid #666',\n      borderRight: '1px solid #666',\n      color: '#666',\n      fontFamily: 'Courier',\n      width: 130,\n      zIndex: 9999,\n      textAlign: 'right',\n      top: opts.position.indexOf('top') === -1 ? null : 0,\n      bottom: opts.position.indexOf('bottom') === -1 ? null : 0,\n      right: opts.position.indexOf('right') === -1 ? null : 0,\n      left: opts.position.indexOf('left') === -1 ? null : 0\n    }\n  }, opts || {});\n\n  hijackDigest();\n\n  // setup the state\n  var state = current = {active: true};\n\n  // auto-load on startup\n  if (opts.autoload) {\n    if (opts.autoload === 'localStorage') {\n      localStorage.setItem(autoloadKey, JSON.stringify(opts));\n    } else if (opts.autoload === 'sessionStorage' || typeof opts.autoload === 'boolean') {\n      sessionStorage.setItem(autoloadKey, JSON.stringify(opts));\n    } else {\n      throw new Error(\n        'Invalid value for autoload: ' + opts.autoload + ' can only be \"localStorage\" \"sessionStorage\" or boolean.'\n      );\n    }\n  }\n\n  // general variables\n  var bodyEl = angular.element(document.body);\n  var noDigestSteps = 0;\n\n  // add the DOM element\n  var htmlId = opts.htmlId ? (' id=\"' + opts.htmlId + '\"') : '';\n  state.$el = angular.element('<div' + htmlId +\n      '><canvas></canvas><div><span></span> | <span></span></div></div>').css(opts.styles);\n  bodyEl.append(state.$el);\n  var $watchCount = state.$el.find('span');\n  var $digestTime = $watchCount.next();\n\n  // initialize the canvas\n  var graphSz = {width: 130, height: 40};\n  var cvs = state.$el.find('canvas').attr(graphSz)[0];\n\n\n  // add listeners\n  listeners.digestLength.ngStatsAddToCanvas = function(digestLength) {\n    addDataToCanvas(null, digestLength);\n  };\n\n  listeners.watchCount.ngStatsAddToCanvas = function(watchCount) {\n    addDataToCanvas(watchCount);\n  };\n\n  track('digest', listeners.digestLength);\n  track('watches', listeners.watchCount, true);\n\n  log('digest', listeners.digestLength);\n  log('watches', listeners.watchCount, true);\n\n  function track(thingToTrack, listenerCollection, diffOnly) {\n    var capThingToTrack = thingToTrack.charAt(0).toUpperCase() + thingToTrack.slice(1);\n    if (opts['track' + capThingToTrack]) {\n      returnData[thingToTrack] = [];\n      listenerCollection['track + capThingToTrack'] = function(tracked) {\n        if (!diffOnly || returnData[thingToTrack][returnData.length - 1] !== tracked) {\n          returnData[thingToTrack][returnData.length - 1] = tracked;\n          returnData[thingToTrack].push(tracked);\n        }\n      };\n    }\n  }\n\n  function log(thingToLog, listenerCollection, diffOnly) {\n    var capThingToLog = thingToLog.charAt(0).toUpperCase() + thingToLog.slice(1);\n    if (opts['log' + capThingToLog]) {\n      var last;\n      listenerCollection['log' + capThingToLog] = function(tracked) {\n        if (!diffOnly || last !== tracked) {\n          last = tracked;\n          var color = colorLog(thingToLog, tracked);\n          if (color) {\n            console.log('%c' + thingToLog + ':', color, tracked);\n          } else {\n            console.log(thingToLog + ':', tracked);\n          }\n        }\n      };\n    }\n  }\n\n  function getColor(metric, threshold) {\n    if (metric > threshold) {\n      return 'red';\n    } else if (metric > 0.7 * threshold) {\n      return 'orange';\n    }\n    return 'green';\n  }\n\n  function colorLog(thingToLog, tracked) {\n    var color;\n    if (thingToLog === 'digest') {\n      color = 'color:' + getColor(tracked, opts.digestTimeThreshold);\n    } else if (thingToLog === 'watches') {\n      color = 'color:' + getColor(tracked, opts.watchCountThreshold);\n    }\n    return color;\n  }\n\n  function addDataToCanvas(watchCount, digestLength) {\n    var averageDigest = digestLength || lastDigestLength;\n    var digestColor = getColor(averageDigest, opts.digestTimeThreshold);\n    lastWatchCount = nullOrUndef(watchCount) ? lastWatchCount : watchCount;\n    var watchColor = getColor(lastWatchCount, opts.watchCountThreshold);\n    lastDigestLength = nullOrUndef(digestLength) ? lastDigestLength : digestLength;\n    $watchCount.text(lastWatchCount).css({color: watchColor});\n    $digestTime.text(lastDigestLength.toFixed(2)).css({color: digestColor});\n\n    if (!digestLength) {\n      return;\n    }\n\n    // color the sliver if this is the first step\n    var ctx = cvs.getContext('2d');\n    if (noDigestSteps > 0) {\n      noDigestSteps = 0;\n      ctx.fillStyle = '#333';\n      ctx.fillRect(graphSz.width - 1, 0, 1, graphSz.height);\n    }\n\n    // mark the point on the graph\n    ctx.fillStyle = digestColor;\n    ctx.fillRect(graphSz.width - 1, Math.max(0, graphSz.height - averageDigest), 2, 2);\n  }\n\n  // Shift the canvas to the left.\n  function shiftLeft() {\n    if (state.active) {\n      window.self.setTimeout(shiftLeft, 250);\n      var ctx = cvs.getContext('2d');\n      var imageData = ctx.getImageData(1, 0, graphSz.width - 1, graphSz.height);\n      ctx.putImageData(imageData, 0, 0);\n      ctx.fillStyle = ((noDigestSteps++) > 2) ? 'black' : '#333';\n      ctx.fillRect(graphSz.width - 1, 0, 1, graphSz.height);\n    }\n  }\n\n  // start everything\n  shiftLeft();\n  if (!$rootScope.$$phase) {\n    $rootScope.$digest();\n  }\n\n  return returnData;\n}\n\nangular.module('angularStats', []).directive('angularStats', function() {\n  var index = 1;\n  return {\n    scope: {\n      digestLength: '@',\n      watchCount: '@',\n      watchCountRoot: '@',\n      onDigestLengthUpdate: '&?',\n      onWatchCountUpdate: '&?'\n    },\n    link: function(scope, el, attrs) {\n      hijackDigest();\n      var directiveIndex = index++;\n\n      setupDigestLengthElement();\n      setupWatchCountElement();\n      addWatchCountListener();\n      addDigestLengthListener();\n      scope.$on('$destroy', destroyListeners);\n\n      function setupDigestLengthElement() {\n        if (attrs.hasOwnProperty('digestLength')) {\n          var digestEl = el;\n          if (attrs.digestLength) {\n            digestEl = angular.element(el[0].querySelector(attrs.digestLength));\n          }\n          listeners.digestLength['ngStatsDirective' + directiveIndex] = function(length) {\n            window.dirDigestNode = digestEl[0];\n            digestEl.text((length || 0).toFixed(2));\n          };\n        }\n      }\n\n      function setupWatchCountElement() {\n        if (attrs.hasOwnProperty('watchCount')) {\n          var watchCountRoot;\n          var watchCountEl = el;\n          if (scope.watchCount) {\n            watchCountEl = angular.element(el[0].querySelector(attrs.watchCount));\n          }\n\n          if (scope.watchCountRoot) {\n            if (scope.watchCountRoot === 'this') {\n              watchCountRoot = el;\n            } else {\n              // In the case this directive is being compiled and it's not in the dom,\n              // we're going to do the find from the root of what we have...\n              var rootParent;\n              if (attrs.hasOwnProperty('watchCountOfChild')) {\n                rootParent = el[0];\n              } else {\n                rootParent = findRootOfElement(el);\n              }\n              watchCountRoot = angular.element(rootParent.querySelector(scope.watchCountRoot));\n              if (!watchCountRoot.length) {\n                throw new Error('no element at selector: ' + scope.watchCountRoot);\n              }\n            }\n          }\n\n          listeners.watchCount['ngStatsDirective' + directiveIndex] = function(count) {\n            var watchCount = count;\n            if (watchCountRoot) {\n              watchCount = getWatcherCountForElement(watchCountRoot);\n            }\n            watchCountEl.text(watchCount);\n          };\n        }\n      }\n\n      function addWatchCountListener() {\n        if (attrs.hasOwnProperty('onWatchCountUpdate')) {\n          listeners.watchCount['ngStatsDirectiveUpdate' + directiveIndex] = function(count) {\n            scope.onWatchCountUpdate({watchCount: count});\n          };\n        }\n      }\n\n      function addDigestLengthListener() {\n        if (attrs.hasOwnProperty('onDigestLengthUpdate')) {\n          listeners.digestLength['ngStatsDirectiveUpdate' + directiveIndex] = function(length) {\n            scope.onDigestLengthUpdate({digestLength: length});\n          };\n        }\n      }\n\n      function destroyListeners() {\n        delete listeners.digestLength['ngStatsDirectiveUpdate' + directiveIndex];\n        delete listeners.watchCount['ngStatsDirectiveUpdate' + directiveIndex];\n        delete listeners.digestLength['ngStatsDirective' + directiveIndex];\n        delete listeners.watchCount['ngStatsDirective' + directiveIndex];\n      }\n    }\n  };\n\n  function findRootOfElement(el) {\n    var parent = el[0];\n    while (parent.parentElement) {\n      parent = parent.parentElement;\n    }\n    return parent;\n  }\n});\n\n// UTILITY FUNCTIONS\n\nfunction getRootScope() {\n  if ($rootScope) {\n    return $rootScope;\n  }\n  var scopeEl = document.querySelector(scopeSelectors);\n  if (!scopeEl) {\n    return null;\n  }\n  $rootScope = angular.element(scopeEl).scope().$root;\n  return $rootScope;\n}\n\n// Uses timeouts to ensure that this is only run every 300ms (it's a perf bottleneck)\nfunction getWatcherCount() {\n  window.self.clearTimeout(watchCountTimeout);\n  var now = timerNow();\n  if (now - lastWatchCountRun > 300) {\n    lastWatchCountRun = now;\n    lastWatchCount = getWatcherCountForScope();\n  } else {\n    watchCountTimeout = window.self.setTimeout(function() {\n      updateData(getWatcherCount());\n    }, 350);\n  }\n  return lastWatchCount;\n}\n\nfunction getWatcherCountForElement(element) {\n  var startingScope = getClosestChildScope(element);\n  return getWatcherCountForScope(startingScope);\n}\n\nfunction getClosestChildScope(element) {\n  element = angular.element(element);\n  var scope = element.scope();\n  if (!scope) {\n    element = angular.element(element.querySelector(scopeSelectors));\n    scope = element.scope();\n  }\n  return scope;\n}\n\nfunction getWatchersFromScope(scope) {\n  return scope && scope.$$watchers ? scope.$$watchers : [];\n}\n\n// iterate through listeners to call them with the watchCount and digestLength\nfunction updateData(watchCount, digestLength) {\n  // update the listeners\n  if (!nullOrUndef(watchCount)) {\n    angular.forEach(listeners.watchCount, function(listener) {\n      listener(watchCount);\n    });\n  }\n  if (!nullOrUndef(digestLength)) {\n    angular.forEach(listeners.digestLength, function(listener) {\n      listener(digestLength);\n    });\n  }\n}\n\nfunction nullOrUndef(item) {\n  return item === null || item === undefined;\n}\n\nfunction getWatcherCountForScope(scope) {\n  var count = 0;\n  iterateScopes(scope, function(childScope) {\n    count += getWatchersFromScope(childScope).length;\n  });\n  return count;\n}\n\nfunction iterateScopes(currentScope, fn) {\n  if (typeof currentScope === 'function') {\n    fn = currentScope;\n    currentScope = null;\n  }\n  currentScope = currentScope || getRootScope();\n  currentScope = _makeScopeReference(currentScope);\n  if (!currentScope) {\n    return;\n  }\n  var ret = fn(currentScope);\n  if (ret === false) {\n    return ret;\n  }\n  return iterateChildren(currentScope, fn);\n}\n\nfunction iterateSiblings(start, fn) {\n  var ret;\n  /* eslint no-extra-boolean-cast:0 */\n  while (!!(start = start.$$nextSibling)) {\n    ret = fn(start);\n    if (ret === false) {\n      break;\n    }\n\n    ret = iterateChildren(start, fn);\n    if (ret === false) {\n      break;\n    }\n  }\n  return ret;\n}\n\nfunction iterateChildren(start, fn) {\n  var ret;\n  while (!!(start = start.$$childHead)) {\n    ret = fn(start);\n    if (ret === false) {\n      break;\n    }\n\n    ret = iterateSiblings(start, fn);\n    if (ret === false) {\n      break;\n    }\n  }\n  return ret;\n}\n\n\nfunction getScopeById(id) {\n  var myScope = null;\n  iterateScopes(function(scope) {\n    if (scope.$id === id) {\n      myScope = scope;\n      return false;\n    }\n  });\n  return myScope;\n}\n\nfunction _makeScopeReference(scope) {\n  if (_isScopeId(scope)) {\n    scope = getScopeById(scope);\n  }\n  return scope;\n}\n\nfunction _isScopeId(scope) {\n  return typeof scope === 'string' || typeof scope === 'number';\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./index.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular\"\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}